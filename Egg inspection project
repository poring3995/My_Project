import os
import cv2
from collections import defaultdict
from ultralytics import YOLO
from datetime import datetime


# Part 1: Setting the variable, uploading ML weight, setting up the dictionary, and saving path.

class EggInspection:
    def __init__(self):

        # 1.1  used 2 models:

            # 1st model: object detection model for tracking the eggs in the video, and crop it for process in the 2nd model
            # 2nd model: object detection model for detecting the defect of the eggs.
        
        self.model_detection = YOLO(r"D:\backup before crash\egg inspection\all model weight\Weight_egg_detection_l_10ep__model\weights\best.pt", "v8")
        self.model_detection2 = YOLO(r"d:\backup before crash\egg inspection\all model weight\RY_egg_detectclassify_n_20ep__model\weights\best_n_20_ry.pt", "v8")
        

        # Since the video or streaming that we are going to analyze will be of the 6 lanes of The Eggs rotating on a conveyor belt.

        # 1.2 The concept for analyzing the defect types :

           # 1.2.1 The 1st model will keep track of the egg for every frame to get different sides of the egg for every frame
           # 1.2.2 The 2nd model will analyze the images of each egg individually from the cropped images and store the prediction result of each egg for every frame, to conclude the answer for each egg (the criteria for concluding the answer will be mentioned later).
           # 1.2.3 The answer of each egg will be starting to concluded only after that egg is out of frame. once the egg is out of frame, the program will gather all of the predicted results of the eggs and conclude them into a single answer.
           # 1.2.4 The eggs that are classified as any defect types (or normal) from the answer will be saved it to each class file, the text file will be writing the last postion of the egg before out of frame to sending it to the machine.

        # **** note: the concept of connecting with the machine is still preliminary preparation and hasn't been done yet in this phase. *******
        
             

        # 1.3 created an array to store the prediction answer, the last position before that egg out of frame, and the missing frame count to check eggs out of frame.
        
       
        self.classify_history = defaultdict(list)
        self.last_positions = {}
        self.missing_frames = defaultdict(int)

        # 1.4 Set up the path for saving images of defect/normal egg images, as well as the text files to store each egg's last position on the frame 

        self.output_text_path = r"D:\backup before crash\egg inspection\testing realtime save\result.txt"
        self.save_defect = r"D:\backup before crash\egg inspection\testing realtime save\crack"
        self.save_normal = r"D:\backup before crash\egg inspection\testing realtime save\normal"

        # 1.5 Set up max missing for counting the frames where some eggs are missing. If the program finds that the egg is out of frame for 5 frames, the answer will be concluded for that egg.
        
        self.max_missing = 5  

        # 1.6 Create a folder from 1.4 

        os.makedirs(self.save_defect, exist_ok=True)
        os.makedirs(self.save_normal, exist_ok=True)

    # Part 2: Class Setup

    # Each crop egg image separately from the full frame
    def crop_box(self, frame, xyxy):
        x1, y1, x2, y2 = map(int, xyxy)
        return frame[y1:y2, x1:x2]
        
    # to gather all of the predicted results of the eggs and combine them into a single answer
    
    # There are 2 types of the class right now, which include :
    # 1. normal egg
    # 2. crack egg (defect)
    # The criteria for concluding the answer (The other defect will be added later according to the given data provider) :
    # ***** Noted: the criteria will be changed based on the test, the actual experiment, for now it will be set as standard case *******
    #   1. For every frame, if the model finds the crack in at least 1 frame, the answer will be concluded as a crack
    #   2. If there is no crack for every frame, the answer will be concluded as a normal egg
            
             
    def summarize_and_save(self, egg_id):
        history = self.classify_history[egg_id]
        last_pos = self.last_positions.get(egg_id, (0, 0))
        decision = "defect" if history.count("defect") >= 1 else "normal"

        with open(self.output_text_path, 'a') as f:
            f.write(f"egg id : {egg_id} , answer : {decision} , position (x,y) : ({last_pos[0]},{last_pos[1]})\n")

  
        del self.classify_history[egg_id]
        del self.last_positions[egg_id]
        del self.missing_frames[egg_id]

    # The main class for running the program

    def run(self):

        # 2.1 receiving input from the video read by cv2
        # ******* Note: in the real use case scenario, the setup will be different, it will be receiving the real-time streaming from the camera instead **********
        cap = cv2.VideoCapture(r"C:\Users\Nattanon\MVS\Data\MV-CS050-10GC (DA2967405)\Video_20250520173047050.avi")
        
        while cap.isOpened():

            # 2.2 Checking connection status
            success, frame = cap.read()
            if not success:
                break
                
            # 2.3 Applied the 1st model to detect the eggs in the frame
            results_t = self.model_detection.track(frame, persist=True, tracker="bytetrack.yaml")
            if not results_t or results_t[0].boxes is None:
                continue

            # 2.4 get each egg's detection box to crop it separately later
            boxes = results_t[0].boxes
            ids = boxes.id.int().tolist() if boxes.id is not None else []

            # 2.5 Create a set to store the egg IDs seen in this frame
            current_eggs = set()


            # 2.6 Starting the loop to store egg ID, last position, and applying the crop images to the 2nd model for detecting the defect in those images.
            for i, box in enumerate(boxes.xyxy.cpu().numpy()):
                egg_id = ids[i]
                current_eggs.add(egg_id)
                self.last_positions[egg_id] = ((int(box[0]) + int(box[2])) // 2, (int(box[1]) + int(box[3])) // 2)

                crop = self.crop_box(frame, box)

                # 2.6.1 Run 2nd model (object detection model)
                result_cls = self.model_detection2.track(crop, persist=True, tracker="bytetrack.yaml")
                found_defect = result_cls[0].boxes is not None and len(result_cls[0].boxes) > 0

                # 2.6.2 Saving the image in each folder depends on the class of the egg
                img_name = f"{egg_id}_{datetime.now().strftime('%H%M%S%f')}.jpg"
                if found_defect:
                    out_img = result_cls[0].plot()
                    cv2.imwrite(os.path.join(self.save_defect, img_name), out_img)
                    self.classify_history[egg_id].append("defect")
                else:
                    cv2.imwrite(os.path.join(self.save_normal, img_name), crop)
                    self.classify_history[egg_id].append("normal")

            # 2.7 Update missing frame count
            for egg_id in list(self.last_positions.keys()):
                if egg_id not in current_eggs:
                    self.missing_frames[egg_id] += 1
                    if self.missing_frames[egg_id] >= self.max_missing:
                        self.summarize_and_save(egg_id)
                else:
                    self.missing_frames[egg_id] = 0

       
if __name__ == "__main__":
    inspection = EggInspection()
    inspection.run()

